/*
 * Invokation API
 *
 * ## Introduction Welcome to the Invokation REST API.  Soon you too will wield the full power of our skill ratings and matchmaking systems.  ## Authentication The Invokation API uses API keys to authenticate requests. You can view and manage your API keys in the Invokation dashboard.  Your API keys carry many privileges, make sure to keep them secure! Do not share your secret API keys in publicly accessible areas such as Github, client-side code and so forth.  All API requests must be made over [HTTPS](http://en.wikipedia.org/wiki/HTTP_Secure). Calls made over plain HTTP will fail. API requests without authentication will also fail.  ## Compression  You can enable compression by including the `Accept-Encoding` header in your request.  We support the following compression algorithms: `zstd`, `br`, `gzip` or `deflate`.   ## Support If you need help, don't hesitate to reach out to us at support@invokation.games or join our [Community Discord](https://discord.gg/JfNGsunrjX). 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@invokation.games
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = Invokation.Skill.Sdk.Client.FileParameter;
using OpenAPIDateConverter = Invokation.Skill.Sdk.Client.OpenAPIDateConverter;

namespace Invokation.Skill.Sdk.Model
{
    /// <summary>
    /// PlayerSession
    /// </summary>
    [DataContract(Name = "PlayerSession")]
    public partial class PlayerSession : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerSession" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected PlayerSession() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerSession" /> class.
        /// </summary>
        /// <param name="adjustedMmr">Adjusted MMR that was used for matchmaking / team-balancing. For example; players who are in a party will often perform better than their individual MMR would suggest A matchmaker or teambalancer might take this into account by calculating a bonus to the MMR However, such a bonus could cause a party to gain more or lose less MMR than they would otherwise By providing this value, we can compensate for this effect..</param>
        /// <param name="botLevel">If this is a bot, an optional bot skill level for analytics purposes Default: null.</param>
        /// <param name="isBot">Used to flag this session as a Bot session.</param>
        /// <param name="partyId">Local identifier of the player&#39;s party. If set, should be unique per party per match. Default behavior is to treat each player as their own party, so party_id can be omitted for games that don&#39;t support parties..</param>
        /// <param name="perfBeta">Override for rating uncertainty (advanced option) Default behavior is to use values generated by model.</param>
        /// <param name="playerId">The unique identifier of the player (required).</param>
        /// <param name="playerScore">The player score in this match Default: 0 It&#39;s up to the game to determine this value. The only requirement is that a higher score is better than a lower score. This value only matters if player performance is configured to have non-zero weight. (required).</param>
        /// <param name="playerScoreStart">The player&#39;s score at the start of this session (advanced option) Default behavior is to inherit player_score from the end of the previous session (recommended) Used for score-per-minute normalization in cases where players can rejoin matches e.g. set this to 0 if player scores are reset on rejoin.</param>
        /// <param name="priorGamesPlayed">The previous number of games the player has played (ever, or just this season)..</param>
        /// <param name="priorMmr">The MMR of the player at the start of the match. A number between 0 and 1 Default: default_mmr specified in the MMR configuration.</param>
        /// <param name="priorMomentum">Incoming momentum (**not used in most models**) For models with experimental anti-smurfing features or rating acceleration Essentially rolling-average win rate.</param>
        /// <param name="sessionTimestamps">sessionTimestamps.</param>
        /// <param name="teamId">Local identifier of the player&#39;s team. If set must match one of the teams provided in the MatchResult. Default behavior is to treat each player as their own team, so team_id can be omitted for 1v1 or free-for-all modes..</param>
        public PlayerSession(double? adjustedMmr = default(double?), double? botLevel = default(double?), bool? isBot = default(bool?), string partyId = default(string), double? perfBeta = default(double?), string playerId = default(string), double playerScore = default(double), double? playerScoreStart = default(double?), long priorGamesPlayed = default(long), double? priorMmr = default(double?), double? priorMomentum = default(double?), PlayerSessionTimestamps sessionTimestamps = default(PlayerSessionTimestamps), string teamId = default(string))
        {
            // to ensure "playerId" is required (not null)
            if (playerId == null)
            {
                throw new ArgumentNullException("playerId is a required property for PlayerSession and cannot be null");
            }
            this.PlayerId = playerId;
            this.PlayerScore = playerScore;
            this.AdjustedMmr = adjustedMmr;
            this.BotLevel = botLevel;
            this.IsBot = isBot;
            this.PartyId = partyId;
            this.PerfBeta = perfBeta;
            this.PlayerScoreStart = playerScoreStart;
            this.PriorGamesPlayed = priorGamesPlayed;
            this.PriorMmr = priorMmr;
            this.PriorMomentum = priorMomentum;
            this.SessionTimestamps = sessionTimestamps;
            this.TeamId = teamId;
        }

        /// <summary>
        /// Adjusted MMR that was used for matchmaking / team-balancing. For example; players who are in a party will often perform better than their individual MMR would suggest A matchmaker or teambalancer might take this into account by calculating a bonus to the MMR However, such a bonus could cause a party to gain more or lose less MMR than they would otherwise By providing this value, we can compensate for this effect.
        /// </summary>
        /// <value>Adjusted MMR that was used for matchmaking / team-balancing. For example; players who are in a party will often perform better than their individual MMR would suggest A matchmaker or teambalancer might take this into account by calculating a bonus to the MMR However, such a bonus could cause a party to gain more or lose less MMR than they would otherwise By providing this value, we can compensate for this effect.</value>
        [DataMember(Name = "adjusted_mmr", EmitDefaultValue = false)]
        public double? AdjustedMmr { get; set; }

        /// <summary>
        /// If this is a bot, an optional bot skill level for analytics purposes Default: null
        /// </summary>
        /// <value>If this is a bot, an optional bot skill level for analytics purposes Default: null</value>
        [DataMember(Name = "bot_level", EmitDefaultValue = false)]
        public double? BotLevel { get; set; }

        /// <summary>
        /// Used to flag this session as a Bot session
        /// </summary>
        /// <value>Used to flag this session as a Bot session</value>
        [DataMember(Name = "is_bot", EmitDefaultValue = false)]
        public bool? IsBot { get; set; }

        /// <summary>
        /// Local identifier of the player&#39;s party. If set, should be unique per party per match. Default behavior is to treat each player as their own party, so party_id can be omitted for games that don&#39;t support parties.
        /// </summary>
        /// <value>Local identifier of the player&#39;s party. If set, should be unique per party per match. Default behavior is to treat each player as their own party, so party_id can be omitted for games that don&#39;t support parties.</value>
        [DataMember(Name = "party_id", EmitDefaultValue = false)]
        public string PartyId { get; set; }

        /// <summary>
        /// Override for rating uncertainty (advanced option) Default behavior is to use values generated by model
        /// </summary>
        /// <value>Override for rating uncertainty (advanced option) Default behavior is to use values generated by model</value>
        [DataMember(Name = "perf_beta", EmitDefaultValue = false)]
        public double? PerfBeta { get; set; }

        /// <summary>
        /// The unique identifier of the player
        /// </summary>
        /// <value>The unique identifier of the player</value>
        [DataMember(Name = "player_id", IsRequired = true, EmitDefaultValue = false)]
        public string PlayerId { get; set; }

        /// <summary>
        /// The player score in this match Default: 0 It&#39;s up to the game to determine this value. The only requirement is that a higher score is better than a lower score. This value only matters if player performance is configured to have non-zero weight.
        /// </summary>
        /// <value>The player score in this match Default: 0 It&#39;s up to the game to determine this value. The only requirement is that a higher score is better than a lower score. This value only matters if player performance is configured to have non-zero weight.</value>
        [DataMember(Name = "player_score", IsRequired = true, EmitDefaultValue = false)]
        public double PlayerScore { get; set; }

        /// <summary>
        /// The player&#39;s score at the start of this session (advanced option) Default behavior is to inherit player_score from the end of the previous session (recommended) Used for score-per-minute normalization in cases where players can rejoin matches e.g. set this to 0 if player scores are reset on rejoin
        /// </summary>
        /// <value>The player&#39;s score at the start of this session (advanced option) Default behavior is to inherit player_score from the end of the previous session (recommended) Used for score-per-minute normalization in cases where players can rejoin matches e.g. set this to 0 if player scores are reset on rejoin</value>
        [DataMember(Name = "player_score_start", EmitDefaultValue = false)]
        public double? PlayerScoreStart { get; set; }

        /// <summary>
        /// The previous number of games the player has played (ever, or just this season).
        /// </summary>
        /// <value>The previous number of games the player has played (ever, or just this season).</value>
        [DataMember(Name = "prior_games_played", EmitDefaultValue = false)]
        public long PriorGamesPlayed { get; set; }

        /// <summary>
        /// The MMR of the player at the start of the match. A number between 0 and 1 Default: default_mmr specified in the MMR configuration
        /// </summary>
        /// <value>The MMR of the player at the start of the match. A number between 0 and 1 Default: default_mmr specified in the MMR configuration</value>
        [DataMember(Name = "prior_mmr", EmitDefaultValue = false)]
        public double? PriorMmr { get; set; }

        /// <summary>
        /// Incoming momentum (**not used in most models**) For models with experimental anti-smurfing features or rating acceleration Essentially rolling-average win rate
        /// </summary>
        /// <value>Incoming momentum (**not used in most models**) For models with experimental anti-smurfing features or rating acceleration Essentially rolling-average win rate</value>
        [DataMember(Name = "prior_momentum", EmitDefaultValue = false)]
        public double? PriorMomentum { get; set; }

        /// <summary>
        /// Gets or Sets SessionTimestamps
        /// </summary>
        [DataMember(Name = "session_timestamps", EmitDefaultValue = false)]
        public PlayerSessionTimestamps SessionTimestamps { get; set; }

        /// <summary>
        /// Local identifier of the player&#39;s team. If set must match one of the teams provided in the MatchResult. Default behavior is to treat each player as their own team, so team_id can be omitted for 1v1 or free-for-all modes.
        /// </summary>
        /// <value>Local identifier of the player&#39;s team. If set must match one of the teams provided in the MatchResult. Default behavior is to treat each player as their own team, so team_id can be omitted for 1v1 or free-for-all modes.</value>
        [DataMember(Name = "team_id", EmitDefaultValue = false)]
        public string TeamId { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class PlayerSession {\n");
            sb.Append("  AdjustedMmr: ").Append(AdjustedMmr).Append("\n");
            sb.Append("  BotLevel: ").Append(BotLevel).Append("\n");
            sb.Append("  IsBot: ").Append(IsBot).Append("\n");
            sb.Append("  PartyId: ").Append(PartyId).Append("\n");
            sb.Append("  PerfBeta: ").Append(PerfBeta).Append("\n");
            sb.Append("  PlayerId: ").Append(PlayerId).Append("\n");
            sb.Append("  PlayerScore: ").Append(PlayerScore).Append("\n");
            sb.Append("  PlayerScoreStart: ").Append(PlayerScoreStart).Append("\n");
            sb.Append("  PriorGamesPlayed: ").Append(PriorGamesPlayed).Append("\n");
            sb.Append("  PriorMmr: ").Append(PriorMmr).Append("\n");
            sb.Append("  PriorMomentum: ").Append(PriorMomentum).Append("\n");
            sb.Append("  SessionTimestamps: ").Append(SessionTimestamps).Append("\n");
            sb.Append("  TeamId: ").Append(TeamId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // PriorGamesPlayed (long) minimum
            if (this.PriorGamesPlayed < (long)0)
            {
                yield return new ValidationResult("Invalid value for PriorGamesPlayed, must be a value greater than or equal to 0.", new [] { "PriorGamesPlayed" });
            }

            // PriorMmr (double?) maximum
            if (this.PriorMmr > (double?)1)
            {
                yield return new ValidationResult("Invalid value for PriorMmr, must be a value less than or equal to 1.", new [] { "PriorMmr" });
            }

            // PriorMmr (double?) minimum
            if (this.PriorMmr < (double?)0)
            {
                yield return new ValidationResult("Invalid value for PriorMmr, must be a value greater than or equal to 0.", new [] { "PriorMmr" });
            }

            yield break;
        }
    }

}
