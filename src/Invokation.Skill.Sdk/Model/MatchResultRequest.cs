/*
 * Invokation API
 *
 * ## Introduction Welcome to the Invokation REST API.  Soon you too will wield the full power of our skill ratings and matchmaking systems.  ## Authentication The Invokation API uses API keys to authenticate requests. You can view and manage your API keys in the Invokation dashboard.  Your API keys carry many privileges, make sure to keep them secure! Do not share your secret API keys in publicly accessible areas such as Github, client-side code and so forth.  All API requests must be made over [HTTPS](http://en.wikipedia.org/wiki/HTTP_Secure). Calls made over plain HTTP will fail. API requests without authentication will also fail.  ## Compression  You can enable compression by including the `Accept-Encoding` header in your request.  We support the following compression algorithms: `zstd`, `br`, `gzip` or `deflate`.   ## Support If you need help, don't hesitate to reach out to us at support@invokation.games or join our [Community Discord](https://discord.gg/JfNGsunrjX). 
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@invokation.games
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = Invokation.Skill.Sdk.Client.FileParameter;
using OpenAPIDateConverter = Invokation.Skill.Sdk.Client.OpenAPIDateConverter;

namespace Invokation.Skill.Sdk.Model
{
    /// <summary>
    /// MatchResultRequest
    /// </summary>
    [DataContract(Name = "MatchResultRequest")]
    public partial class MatchResultRequest : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MatchResultRequest" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected MatchResultRequest() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MatchResultRequest" /> class.
        /// </summary>
        /// <param name="matchEndTs">Time the match ended (ISO 8601 UTC timestamp). Apart from backfilling historical data or simulations, you probably don&#39;t need to pass this..</param>
        /// <param name="matchId">Unique match identifier.</param>
        /// <param name="matchStartTs">Time the match started (ISO 8601 UTC timestamp). Apart from backfilling historical data or simulations, you probably don&#39;t need to pass this..</param>
        /// <param name="metadata">Several properties to provide more context about the match.</param>
        /// <param name="playerSessions">A list of all player sessions for one single match. There can be multiple sessions for the same player. (required).</param>
        /// <param name="teams">A list of teams and their metadata (required).</param>
        public MatchResultRequest(DateTimeOffset? matchEndTs = default(DateTimeOffset?), string matchId = default(string), DateTimeOffset? matchStartTs = default(DateTimeOffset?), MatchMetadata metadata = default(MatchMetadata), Collection<PlayerSession> playerSessions = default(Collection<PlayerSession>), Collection<TeamInfo> teams = default(Collection<TeamInfo>))
        {
            // to ensure "playerSessions" is required (not null)
            if (playerSessions == null)
            {
                throw new ArgumentNullException("playerSessions is a required property for MatchResultRequest and cannot be null");
            }
            this._PlayerSessions = playerSessions;
            // to ensure "teams" is required (not null)
            if (teams == null)
            {
                throw new ArgumentNullException("teams is a required property for MatchResultRequest and cannot be null");
            }
            this._Teams = teams;
            this._MatchEndTs = matchEndTs;
            if (this.MatchEndTs != null)
            {
                this._flagMatchEndTs = true;
            }
            this._MatchId = matchId;
            if (this.MatchId != null)
            {
                this._flagMatchId = true;
            }
            this._MatchStartTs = matchStartTs;
            if (this.MatchStartTs != null)
            {
                this._flagMatchStartTs = true;
            }
            this._Metadata = metadata;
            if (this.Metadata != null)
            {
                this._flagMetadata = true;
            }
        }

        /// <summary>
        /// Time the match ended (ISO 8601 UTC timestamp). Apart from backfilling historical data or simulations, you probably don&#39;t need to pass this.
        /// </summary>
        /// <value>Time the match ended (ISO 8601 UTC timestamp). Apart from backfilling historical data or simulations, you probably don&#39;t need to pass this.</value>
        [DataMember(Name = "match_end_ts", EmitDefaultValue = true)]
        public DateTimeOffset? MatchEndTs
        {
            get{ return _MatchEndTs;}
            set
            {
                _MatchEndTs = value;
                _flagMatchEndTs = true;
            }
        }
        private DateTimeOffset? _MatchEndTs;
        private bool _flagMatchEndTs;

        /// <summary>
        /// Returns false as MatchEndTs should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeMatchEndTs()
        {
            return _flagMatchEndTs;
        }
        /// <summary>
        /// Unique match identifier
        /// </summary>
        /// <value>Unique match identifier</value>
        [DataMember(Name = "match_id", EmitDefaultValue = true)]
        public string MatchId
        {
            get{ return _MatchId;}
            set
            {
                _MatchId = value;
                _flagMatchId = true;
            }
        }
        private string _MatchId;
        private bool _flagMatchId;

        /// <summary>
        /// Returns false as MatchId should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeMatchId()
        {
            return _flagMatchId;
        }
        /// <summary>
        /// Time the match started (ISO 8601 UTC timestamp). Apart from backfilling historical data or simulations, you probably don&#39;t need to pass this.
        /// </summary>
        /// <value>Time the match started (ISO 8601 UTC timestamp). Apart from backfilling historical data or simulations, you probably don&#39;t need to pass this.</value>
        [DataMember(Name = "match_start_ts", EmitDefaultValue = true)]
        public DateTimeOffset? MatchStartTs
        {
            get{ return _MatchStartTs;}
            set
            {
                _MatchStartTs = value;
                _flagMatchStartTs = true;
            }
        }
        private DateTimeOffset? _MatchStartTs;
        private bool _flagMatchStartTs;

        /// <summary>
        /// Returns false as MatchStartTs should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeMatchStartTs()
        {
            return _flagMatchStartTs;
        }
        /// <summary>
        /// Several properties to provide more context about the match
        /// </summary>
        /// <value>Several properties to provide more context about the match</value>
        [DataMember(Name = "metadata", EmitDefaultValue = true)]
        public MatchMetadata Metadata
        {
            get{ return _Metadata;}
            set
            {
                _Metadata = value;
                _flagMetadata = true;
            }
        }
        private MatchMetadata _Metadata;
        private bool _flagMetadata;

        /// <summary>
        /// Returns false as Metadata should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeMetadata()
        {
            return _flagMetadata;
        }
        /// <summary>
        /// A list of all player sessions for one single match. There can be multiple sessions for the same player.
        /// </summary>
        /// <value>A list of all player sessions for one single match. There can be multiple sessions for the same player.</value>
        [DataMember(Name = "player_sessions", IsRequired = true, EmitDefaultValue = true)]
        public Collection<PlayerSession> PlayerSessions
        {
            get{ return _PlayerSessions;}
            set
            {
                _PlayerSessions = value;
                _flagPlayerSessions = true;
            }
        }
        private Collection<PlayerSession> _PlayerSessions;
        private bool _flagPlayerSessions;

        /// <summary>
        /// Returns false as PlayerSessions should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializePlayerSessions()
        {
            return _flagPlayerSessions;
        }
        /// <summary>
        /// A list of teams and their metadata
        /// </summary>
        /// <value>A list of teams and their metadata</value>
        [DataMember(Name = "teams", IsRequired = true, EmitDefaultValue = true)]
        public Collection<TeamInfo> Teams
        {
            get{ return _Teams;}
            set
            {
                _Teams = value;
                _flagTeams = true;
            }
        }
        private Collection<TeamInfo> _Teams;
        private bool _flagTeams;

        /// <summary>
        /// Returns false as Teams should not be serialized given that it's read-only.
        /// </summary>
        /// <returns>false (boolean)</returns>
        public bool ShouldSerializeTeams()
        {
            return _flagTeams;
        }
        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class MatchResultRequest {\n");
            sb.Append("  MatchEndTs: ").Append(MatchEndTs).Append("\n");
            sb.Append("  MatchId: ").Append(MatchId).Append("\n");
            sb.Append("  MatchStartTs: ").Append(MatchStartTs).Append("\n");
            sb.Append("  Metadata: ").Append(Metadata).Append("\n");
            sb.Append("  PlayerSessions: ").Append(PlayerSessions).Append("\n");
            sb.Append("  Teams: ").Append(Teams).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
